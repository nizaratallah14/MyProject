<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Decal Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #container { width: 100vw; height: 100vh; display: block; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      padding: 8px 12px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="info">
    three.js - decal demo edit<br/>
    Click to shoot
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DecalGeometry } from 'https://unpkg.com/three@0.160.0/examples/jsm/geometries/DecalGeometry.js';

    const container = document.getElementById('container');

    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
    camera.position.z = 120;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.minDistance = 50;
    controls.maxDistance = 200;

    // Lights
    scene.add(new THREE.AmbientLight(0x666666));
    const dir1 = new THREE.DirectionalLight(0xffddcc, 3);
    dir1.position.set(1, 0.75, 0.5);
    scene.add(dir1);
    const dir2 = new THREE.DirectionalLight(0xccccff, 3);
    dir2.position.set(-1, 0.75, -0.5);
    scene.add(dir2);

    // Raycaster & mouse
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let intersects = [];

    // Load decal textures
    const loaderTex = new THREE.TextureLoader();
    const decalDiffuse = loaderTex.load('https://threejs.org/examples/textures/decal/decal-diffuse.png');
    const decalNormal = loaderTex.load('https://threejs.org/examples/textures/decal/decal-normal.jpg');
    decalDiffuse.colorSpace = THREE.SRGBColorSpace;

    const decalMaterial = new THREE.MeshPhongMaterial({
      specular: 0x444444,
      map: decalDiffuse,
      normalMap: decalNormal,
      normalScale: new THREE.Vector2(1,1),
      shininess: 30,
      transparent: true,
      depthTest: true,
      depthWrite: false,
      polygonOffset: true,
      polygonOffsetFactor: -4
    });

    // Decals array
    const decals = [];

    // Mouse helper
    const mouseHelper = new THREE.Mesh(
      new THREE.BoxGeometry(1,1,10),
      new THREE.MeshNormalMaterial()
    );
    mouseHelper.visible = false;
    scene.add(mouseHelper);

    // 3D Model
    let mesh;
    const gltfLoader = new GLTFLoader();
    gltfLoader.load(
      'https://threejs.org/examples/models/gltf/LeePerrySmith/LeePerrySmith.glb',
      function(gltf){
        mesh = gltf.scene.children[0];
        mesh.material = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 25 });
        mesh.scale.multiplyScalar(10);
        scene.add(mesh);
      }
    );

    const position = new THREE.Vector3();
    const orientation = new THREE.Euler();
    const size = new THREE.Vector3(10,10,10);

    function shoot(){
      position.copy(mouseHelper.position);
      orientation.copy(mouseHelper.rotation);
      orientation.z = Math.random()*2*Math.PI;

      const decal = new THREE.Mesh(
        new DecalGeometry(mesh, position, orientation, size),
        decalMaterial.clone()
      );
      decals.push(decal);
      mesh.add(decal);
    }

    // Event listeners
    window.addEventListener('pointermove', function(event){
      if(!mesh) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      intersects = raycaster.intersectObject(mesh, false);

      if(intersects.length > 0){
        mouseHelper.position.copy(intersects[0].point);
        const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
        const n = intersects[0].face.normal.clone().applyNormalMatrix(normalMatrix).multiplyScalar(10).add(intersects[0].point);
        mouseHelper.lookAt(n);
      }
    });

    window.addEventListener('pointerdown', function(){
      if(intersects.length > 0) shoot();
    });

    window.addEventListener('resize', function(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
